#include <stdio.h>
#include <xc.h>
#include <math.h>

#define _XTAL_FREQ 20000000

#pragma config FOSC = HS        // Oscillator Selection bits (HS oscillator)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOREN = ON       // Brown-out Reset Enable bit (BOR enabled)
#pragma config LVP = ON         // Low-Voltage (Single-Supply) In-Circuit Serial Programming Enable bit (RB3/PGM pin has PGM function; low-voltage programming enabled)
#pragma config CPD = OFF        // Data EEPROM Memory Code Protection bit (Data EEPROM code protection off)
#pragma config WRT = OFF        // Flash Program Memory Write Enable bits (Write protection off; all program memory may be written to by EECON control)
#pragma config CP = OFF         // Flash Program Memory Code Protection bit (Code protection off)

#define RS PORTCbits.RC1
#define RW PORTCbits.RC0
#define EN PORTCbits.RC2

int a,b,c,d,e,f;
unsigned int temp,adc;
float temperature,adc1;

void delay(unsigned int i)
{
    while(i--);
}

void lcd_command (unsigned char a)
{
    PORTD = a;
    RS = 0;
    RW = 0;
    EN = 1;
    delay(500);
    EN=0;
}

void chr(unsigned char b)
{
    PORTD = b;
    RS = 1;
    RW = 0;
    EN = 1;
    delay(500);
    EN=0;
}

void str (const char *d, char n)//str = system
{
  char o;
  for(o=0;o<n;o++)
  {
      chr(d[o]);
      delay(500);
  }
}

void lcd_initialise()
{
    lcd_command(0x38);//16x2 model
    lcd_command(0x06);//shift cursor right
    lcd_command(0x0C);//LCD On, cursor off
    lcd_command(0x01);//clear display screen
    
}

void __interrupt() ISR(void)
{
    if (PIR1bits.ADIF == 1)  // Check if ADC interrupt flag is set
    {
        delay(500);
        adc = ((unsigned int)ADRESH << 8)| ADRESL; // Read high byte of ADC result
        adc += ADRESL;       // Add low byte of ADC result
        PIR1bits.ADIF = 0;   // Clear ADC interrupt flag
    }
}


void main(void)
{
    INTCONbits.GIE = 1;//Global Interrupt Enable bit of INTCON register
    INTCONbits.PEIE = 1;//Peripheral Interrupt Enable bit of INTCON register
    PIE1bits.ADIE = 1;//ADC Interrupt Enable bit of PIE1 register

    TRISD = 0x00;
    TRISC = 0x00;

    PORTC = PORTD = 0x00;
    lcd_initialise();
    __delay_ms(100);

    lcd_command(0x80);//First Line, First Row of LCD
    str("SENSOR", 7);

    ADCON0 = 0x41;// 0100 0001, controls operation of ADC module
    ADCON1 = 0x8E;//1000 1110 , configures port pins of ADC module
    
    while (1)
{
    ADCON0 = ADCON0 | 0x04;  // Start ADC conversion by enabling Go_nDone bit of ADCON0 register
    adc1 = adc / 2.046;      // Convert ADC value to voltage (assuming 10-bit ADC and 5V reference)

    temperature = adc1 * 100;  // Scale to get temperature in desired format

    lcd_command(0x89);       // 0123

    a = (int)(temperature / 10.0);//012
    b = (int)fmod(temperature,10.0);//3
    c = a % 10;//2
    d = a / 10;//01
    e = d%10; //1
    f = d/10; //0

    chr(f +0x30);
    chr(e + 0x30);
    chr('.')   ;           // Possibly print a decimal point
    chr(c + 0x30);    // Display digit
    chr(b + 0x30);    // Display digit
    
    str("Centigrade",11);
}
    return;
}
